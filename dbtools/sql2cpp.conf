[CPP]

# The following file will be used for the generated files.
# You can use the full file name. Inside that file, use the following substitutions:
#    [filename]      - the name of the generated file
#    [date]          - the current date
#    [generator]     - the name of the script that generated the file (sql2cpp.pl)
# Any leading or trailing spaces, CR/LF characters or quotes will be stripped off.
fileHeader=test_header.h

# The file extentions for generated C++ files
cppExtention=cpp
hppExtention=h

# C++ and header file indentation. You can use spaces and or tabulations here
indentString="    "

# The Query wrapper class
# The class is used to return a recordset from the stored function.
# The optional [type] template is used to substitute a part of the class name, or as a template
# type. [type] is one of the DB types listed in TypeMapping section. The primary requirements for
# such class are:
#   - it should have ctor taking (sptk::CQuery)
#   - it should have copy ctor
#   - it should have public sptk::CParam& param(std::string paramName) method
# Here is the minimal possible implementation of such class:
#
# template <class T>
# class CRecordSet {
#   sptk::CQuery& m_query;
# public:
#   CRecordSet(sptk::CQuery& query) : m_query(query) {}
#   CRecordSet(const CRecordSet& rs) : m_query(rs.m_query) {}
#   sptk::CParam& param(std::string paramName);
# };
#
queryWrapperClassTemplate=CRecordSet<[type]>

# This is also possible (but with different class implementation):
# queryWrapperClassTemplate=C[type]Set

# The CSV list of extra include files that define the query wrapper class (see above)
extraIncludes={ "CRecordSet.h" }

[TypeMapping]

# For the complex types (table- and view- records), there are the database record types
# (table or view names). If you are using them as procedure parameters or return
# types, you have to create corresponding C++ type. There is only one special requirement
# for these classes: They have to implement void load(CQuery&) method to load the data
# from the current row of the query. The query is assumed to be opened at that moment.
# The script tries converting a table name to C++ style class name. For example, the 
# table name my_data_items becomes C++ class name MyDataItems. If you don't like that,
# you can provide your own alias using '=':

recordTypes={ author, book, my_data_items=DataItems }

# Every database complex type you're using as a parameter or a return type in your
# stored procedure, needs a corresponding C++ class. The name of this class is built
# using [recordtype] substitution.

recordClassTemplate=C[recordtype]Record

# Every processed SQL file creates a C++ class. The name of this class is defined
# by the following template (use [filename] to substitute SQL file name w/o extension):

fileClassTemplate=C[filename]

[Paths]

# The following directory is used to look for .sql files
inputDirectory=sql

# The following directories are used to place generated C++ files
# Only one directory is allowed for each C++ and header generated files
outputCppDirectory=src
outputHppDirectory=src

# Log directory
logDirectory=.

[Commands]

# This section describes optional preprocess and postprocess OS commands
# that are called before and after the processing of every SQL file
# These commands may use SQL-file name as [filename].

preprocess=psql -f [filename]
postprocess=

[Print]

# Verbosity level for stdout (errors printed to stderr):
#   0 - quiet
#   1 - print class names
#   2 - print class names and function names
#   3 - print class names, function names, and commands std output

Verbose=1